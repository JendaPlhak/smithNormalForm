\chapter{Triangularizace celočíselných matic}

V této kapitole se budeme zabývat popisem algoritmu pro výpočet redukovaného
schodovitého tvaru celočíselných matic. Tento algoritmus představil Arne Storjohann
v článku nazvaném ,,\textit{A fast+practial+deterministic algorithm for
triangularizing integer matrices}'' \cite{triang}. Definujme nejdříve tvar matice,
jehož vytvoření bude našim cílem.

\begin{defi}\label{RREF}
    Řekneme že matice $ A \in \Zmat $ je v redukovaném schodovitém tvaru (\rst) jestliže
    splňuje následující podmínky:
    \begin{Cond}
        \item Buď r hodnost matice A. Pak prvních r řádků je nenulových.
        \item Pro každé $ 1 \leq i \leq r $ buď $A[i, j_i]$ první nenulový prvek v
        $ i $-tém řádku. Pak $ j_1 < j_2 < \cdots < j_r $.
        \item Pro každé $ 1 \leq i \leq r $ platí $ A[i, j_i] > 0 $.
        \item Pro každé $ 1 \leq k < i \leq r $ platí $ A[i, j_i] > A[k, j_i] \geq 0 $.
    \end{Cond}
\end{defi}

\begin{pozn}
Poznamenejme, že první a druhá podmínka nám zaručují schodovitý tvar matice $ A $.
Tento však zjevně není jednoznačný. Proto je nutné přidat ještě podmínky
(\textit{c3}) a (\textit{c4}). (\textit{c3}) zajišťuje, že členy nad pivoty budou
kladné a (\textit{c4}) říká, že prvky nad pivoty budou pivoty omezeny. Tyto
podmínky pak určují tvar matice $ A $ jednoznačně vzhledem k elementárním
operacím.
\end{pozn}

\begin{pri}
Pro ilustraci uvádíme následující matici v \rst:
\begin{center}
$
    \begin{pmatrix}
        2 & 33 & 6  & 0 & 39  & 73 \\
        0 & 0  & 24 & 0 & 444 & 8  \\
        0 & 0  & 0  & 1 & 22  & 23 \\
        0 & 0  & 0  & 0 & 0   & 75 \\
        0 & 0  & 0  & 0 & 0   & 0  \\
    \end{pmatrix}
$
\end{center}
\end{pri}

V následujících podkapitolách nejdříve popíšeme několik klíčových procedur, které
budou upravovat vstupní matici $ A $, pomocí unimodulárních (mající determinant
roven $\pm 1$, tedy invertibilních) matic.
Tyto procedury postupně propojíme a v poslední podkapitole pak obdržíme samotný
algoritmus pro výpočet \rst.

\section{GCD redukce}
Jak jsme viděli již v důkazu věty o Smithově normálním tvaru, častou operací,
kterou s maticí při převodu do \snf provádíme, je eliminace všech prvků
nacházejících se pod nějakým námi zvoleným pivotem. Takováto eliminace je poměrně
náročná, neboť pro každý prvek musíme vytvářet největší společný dělitel s pivotem.
Bylo by proto výhodné, kdybychom mohli nějakým způsobem upravit prvky ve sloupci tak,
že největší společný dělitel nějakých dvou prvků daného sloupce bude zároveň největším
společným dělitelem všech prvků daného sloupce. A přesně to je obsahem následující věty.

\begin{vet}[GCD redukce]
    Nechť $ B \in \Zmat $ je matice $ (k+2) \times k $ a $ rank(B) = 2 $, kterou
    můžeme zapsat jako
\begin{center}
$ B =
    \begin{pmatrix}
        N & \bar{N} \\
        a_0 & \bar{a}_0  \\
        b_1 & \bar{b}_1  \\
        \vdots & \vdots  \\
        b_k & \bar{b}_k  \\
    \end{pmatrix}
$,
\end{center}
kde N je kladné.
Pak existuje deterministický algoritmus, který pro matici $ B $ vypočte unimodulární
matici
\begin{center}
$ C =
    \begin{pmatrix}
        1 &    &     &        &     \\
          & 1  & c_1 & \cdots & c_k \\
          &    & 1   &        &     \\
          &    &     & \ddots &     \\
          &    &     &        & 1   \\
    \end{pmatrix}
$
\end{center}
takovou, že bude platit
\begin{center}
$ CB =
    \begin{pmatrix}
        N & \bar{N} \\
        a_k & \bar{a}_k  \\
        b_1 & \bar{b}_1  \\
        \vdots & \vdots  \\
        b_k & \bar{b}_k  \\
    \end{pmatrix}
$ kde dgsdgddg
sdgsdgsdgdgsdgdsdg
\end{center}
a navíc $ CB $ bude splňovat následující podmínky:
\begin{Cond}
    \item hlavní submatice
    $
        \begin{pmatrix}
            N & \bar{N} \\
            a_k & \bar{a}_k  \\
        \end{pmatrix}
    $ je regulární a
    \item $ gcd(N, a_k) = gcd(N, a_0, b_1, b_2, \dots, b_k) $.
\end{Cond}
\end{vet}

\begin{proof}
Bez újmy na obecnosti můžeme předpokládat, že $ k > 0 $. Pokud by k bylo nulové,
můžeme zřejmě za $ C $ zvolit identitu, které splní naše požadavky.
Dále můžeme předpokládat, že hlavní submatice je regulární a tedy platí
$ N \bar{a}_0 - \bar{N} a_0 \neq 0 $. Pokud by tomu tak nebylo, přičteme k druhému
řádku nějaký řádek $ 2 < s \leq k + 2 $, pro který platí
$ N \bar{b}_s - \bar{N} b_s \neq 0 $.
Takový řádek jistě bude existovat, neboť matice $ B $ má plnou hodnost. Výsledná
matice pak bude mít hlavní submatici regulární. Pro takto upravenou matici můžeme
spočítat hledané koeficienty $ c_i $ a konečně ke koeficientu $ c_s $ přičteme $ 1 $,
což bude přesně odpovídat onomu přičtení $ s $-tého řádku, které jsme provedli na
začátku.

Nyní ukážeme, jak iterativně vypočítat $ c_l $ pro $ l = 1,\dots,k $. Označme
mezivýsledky našeho výpočtu následujícím způsobem:
\begin{equation}\label{oznac}
    \begin{split}
        a_l &= a_0 + c_1 b_1 + \dots + c_l b_l \\
        \bar{a}_l &= \bar{a}_0 + c_1 \bar{b}_1 +\dots+c_l \bar{b}_l
    \end{split}
\end{equation}
Po provedení kroku $ l-1 $ a na začátku kroku $ l $ jsou vypočítány koeficienty
$ c_1, \dots, c_{l-1} $ a jsou splněny podmínky
\begin{center}
    \begin{CondNum}
        \item $ gcd(N, a_i) = gcd(N, a_0, b_1, b_2, \dots, b_i) $
        \item $ N \bar{a}_i - \bar{N} a_i \neq 0 $
    \end{CondNum}
\end{center}
pro $ i = l - 1 $. Poznamenejme, že pro $ i = 0 $ jsou podmínky (1)
a (2) splněny triviálně. Teď musíme provést
indukční krok - najít vhodné $ c_l $ takové, že budou splněny podmínky
(1) a (2) pro $ i = l $.

Nechť $ g = gcd(a_{l-1}, b_l) $. Pak můžeme dělením se zbytkem najít celá
čísla $ q_1, q_2 $ a
$ 0 \leq \tilde{a}_{l-1}, \tilde{b}_{l} < N $ taková, že platí

\begin{equation}\label{division}
    \begin{split}
        a_{l - 1} / g & = q_1 N +  \tilde{a}_{l-1} \\
        b_{l} / g & = q_2 N +  \tilde{b}_{l}
    \end{split}
\end{equation}
Čísla $ \tilde{a}_{l-1} $ a $ \tilde{b}_{l} $ jsou nesoudělná, protože TODO. Pomocí
algoritmu uvedeného v TODO můžeme najít nejmenší kladné číslo $ t $ takové, že bude
platit
\begin{equation}\label{t_search}
    gcd(\tilde{a}_{l-1} + t \tilde{b}_{l}, N) = 1
\end{equation}
a volbou $ c_l \leftarrow t $ zajistíme splnění podmínky (1). Skutečně:
\begin{align*}
    gcd(a_l, N) &= gcd(a_{l-1} + t b_l, N) && \text{we are trying to solve for } \\
                &= gcd(g (q_1 N +  \tilde{a}_{l-1})
                        + tg(q_2 N + \tilde{b}_{l}), N) \\
                &= gcd(g (\tilde{a}_{l-1} + t \tilde{b}_{l})
                        + g (q_1 + t q_2) N, N) \\
                &= gcd(g (\tilde{a}_{l-1} + t \tilde{b}_{l}), N) \\
                &= gcd(g, N) \\
                &= gcd(a_{l-1}, b_l, N) \\
                &= gcd(N, a_0, b_1, b_2, \dots, b_l) \\
\end{align*}
přičemž poslední rovnost plyne z indukčního předpokladu.

Nakonec musíme zajistit splnění i druhé podmínky (2). Buď $ l $ index aktuálního
kroku a předpokládejme, že platí

\begin{equation}\label{det}
    \begin{vmatrix}
        N & \bar{N} \\
        a_{l-1} + x b_l & \bar{a}_{l-1} + x \bar{b}_l  \\
    \end{vmatrix}
    = 0
\end{equation}
pak ovšem z indukčního předpokladu plyne, že $ N \bar{b}_l - \bar{N} b_l \neq 0 $.
To implikuje, že prvek x je určen jednoznačně a můžeme jej vyjádřit jako
\begin{equation}\label{frac}
    x = -\frac{N \bar{a}_{l-1} - \bar{N} a_{l-1}} {N \bar{b}_l - \bar{N} b_l}
\end{equation}
Pokud by nám tedy v kroku \ref{t_search} vyšlo $ c_l = t = x $, nebyla by podmínka
(2) splněna. To můžeme ovšem snadno napravit. Předpokládejme tedy, že $ 0 < t = x $
\end{proof}



% \begin{equation*}\label{E}\tag{rovnice}
%  \int\! f(x)\,\mathrm{d}x
% \end{equation*}
% odkaz na rovnici s \uv{tagem} \eqref{E} -- pokud nechcete vzorci přidělit číslo, ale nějaký vlastní symbol, používejte
% \uv{hvězdičkovaná} prostředí, tj. např. \verb+equation*+

% odkaz na druhy vzorec \eqref{EE}

\shorthandoff{-}
\index{nějaká!položka}

\section{Podkapitola}

\index{jiná položka}
\shorthandon{-}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\cleardoublepage

