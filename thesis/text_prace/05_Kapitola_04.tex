\chapter{Paralelizace}

Buď $ A $ celočíselná matice $ n \times m $ a předpokládejme, že $ n < m $. Pak
z Hadamardovy nerovnosti (pro bližší infromace čtenáře odkazujeme na publikaci
\cite{Hadamard}) plyne, že pro libovolný minor $ h $ matice $ A $
platí $ h \leq (m^{1/2} \Vert A \Vert )^m $, kde
$ \Vert A \Vert = max \{ |a^i_j| \} $. Z článku \cite{Had_tight} plyne, že
Hadamardův odhad je poněkud pesimistický a v případě náhodných matic vychází
determinant v průměru menší, přesto však tento odhad dává tušit, že
se v případě počítačové implementace algoritmu pro výpočet Smithova normálního
tvaru můžeme poměrně rychle dostat do problémů s kapacitou celočíselných typů.

Tento problém můžeme řešit knihovnami pro reprezentaci celých čísel libovolné
bitové délky. Nicméně
efektivita takového řešení už není ideální a navíc tento přístup zvyšuje
paměťovou náročnost. Hodilo by se nám proto, kdybychom mohli celý výpočet
rozložit na více částí, pro které už by nebylo problém spočítat výsledek pomocí
standardní 32-bitové aritmetiky a následně všechny částečné vysledky spojit
do hledaného Smithova normálního tvaru. Toho můžeme dosáhnout pomocí Čínské
zbytkové věty.


\begin{vet}[Čínská zbytková věta] \label{Chin_Rem}
Mějme kladná celá čísla $ m_1,\dots,m_k $, která jsou po dvou nesoudělná. Pak
pro libovolnou posloupnost celých čísel $ a_1,\dots,a_k $ existuje celé
číslo $ x $, které je řešením následující soustavy kongruencí.

\begin{equation}
    \begin{aligned} \label{congrs}
        x &\equiv a_1 \pmod{m_1}                   \\
        x &\equiv a_2 \pmod{m_2}                   \\
          &\mathrel{\makebox[\widthof{=}]{\vdots}}  \\
        x &\equiv a_k \pmod{m_k}                   \\
    \end{aligned}
\end{equation}
%
Navíc pro libovolná dvě řešení $ x_1, x_2 $ uvedené soustavy platí
$ x_1 \equiv x_2 \pmod{m_1 m_2 \cdots m_k} $  .
\end{vet}

\begin{proof}
Zaměřme svou pozornost nejprve na existenci řešení. Označme
$ m = m_1 m_2 \cdots m_k $. Pak zřejmě pro každé $ i \in \{1,\dots,k\} $
platí $ \gcd(m_i, m / m_i) = 1 $, protože $ m_i $ jsou po dvou nesoudělná.
Díky tomu můžeme pomocí rozšířeného Euklidova algoritmu najít celá čísla
$ s_i, t_i $ taková, že $ s_i m_i + t_i \frac{m}{m_i} = 1 $. Nyní označme
$ d_i = t_i \frac{m}{m_i} $. Z toho plyne rovnost $ s_i m_i + d_i = 1 $ a
\begin{align*}
d_i \equiv
\left\{
  \begin{array}{lr}
    1 \pmod{ m_j } & : j = i \\
    0 \pmod{ m_j }  & : j \neq i
  \end{array}
\right.
\end{align*}
Skutečně, pokud $ j = i $, tak dostáváme
$ 1 \equiv s_i m_i + d_i \equiv d_i \pmod{m_i} $. Pokud naopak $ j \neq i $, pak
zřejmě $ m_j \mid d_i $ a proto bude $ d_i $ kongruentní s nulou modulo $ m_j $.

Položme $ x = \sum\limits_{i = 1}^{k} a_i d_i $. Pak díky výše uvedené
vlastnosti $ d_i $ bude $ x $ řešením soustavy \eqref{congrs}.

Nechť $ x_1, x_2 \in \Zbb $ jsou dvě libovolná řešení soustavy \eqref{congrs}.
Pak ale $ x_1 \equiv x_2 \pmod{m_i} $, což implikuje $ m_i \mid x_1 - x_2 $.
Protože $ m_i $ jsou po dvou nesoudělná, tak z předchozí implikace dále plyne, že
$ x_1 - x_2 $ bude dělitelné také součinem všech $ m_i $, tedy
$ m \mid x_1 - x_2 $. To je ale ekvivalentní tomu, že
$ x_1 \equiv x_2 \pmod{m} $ a důkaz je hotov.
\end{proof}

\begin{dus} \label{Chin_Rem_Iso}
Mějme kladné číslo $ m $ s faktorizací $ m = p_1^{r_1} \cdots p_k^{r_k}$. Pak
existuje izomorfismus okruhů
$ \Zbb / m \Zbb \cong \Zbb / p_1^{r_1} \Zbb \times \cdots \times \Zbb / p_k^{r_k} \Zbb $
\end{dus}
\begin{proof}
Uvažme zobrazení
$ \varphi : \Zbb / m \Zbb \rightarrow \Zbb / p_1^{r_1} \Zbb \times \cdots \Zbb / p_k^{r_k} \Zbb $
definované jako $ \varphi([x]_m) = ([x]_{p_1^{r_1}},\dots, [x]_{p_k^{r_k}}) $.
Ukážeme, že takto definované zobrazení je izomorfismem okruhů.

Mějme libovolný prvek
$ a = ([a_1]_{p_1^{r_1}},\dots, [a_k]_{p_k^{r_k}}) \in \Zbb / p_1^{r_1} \Zbb \times \cdots \Zbb / p_k^{r_k} \Zbb $.
Pak podle věty \ref{Chin_Rem} můžeme nalézt takové $ x \in \Zbb $, že
%
\begin{equation*}
    \begin{aligned}
        x &\equiv a_1 \pmod{p_1^{r_1}}              \\
          &\mathrel{\makebox[\widthof{=}]{\vdots}}  \\
        x &\equiv a_k \pmod{p_k^{r_k}}.           \\
    \end{aligned}
\end{equation*}
%
Pak ale $ \varphi([x]_m) = a $, z čehož plyne, že $ \varphi $ je surjektivní.

Mějme $ x, y \in \Zbb / m \Zbb $ libolná a předpokládejme
$ \varphi(x) = \varphi(y) $. Pak ale z věty \ref{Chin_Rem} plyne, že
$ x \equiv y \pmod{m} $. $ \varphi $ je proto injekce a díky předchozímu
odstavci také bijekce.

Nakonec ještě ověříme, že se skutečně jedná o homomorfismus okruhů.
Mějme $ x, y \in \Zbb / m \Zbb $ libovolné. Pak
%
\begin{align*}
    \varphi(x + y) &= ([x + y]_{p_1^{r_1}},\dots, [x + y]_{p_k^{r_k}})  \\
                   &= ([x]_{p_1^{r_1}} + [y]_{p_1^{r_1}},\dots, [x]_{p_k^{r_k}} + [y]_{p_k^{r_k}})  \\
                   &= ([x]_{p_1^{r_1}},\dots, [x]_{p_k^{r_k}}) + ([y]_{p_1^{r_1}},\dots, [y]_{p_k^{r_k}}) \\
                   &= \varphi(x) + \varphi(y).
\end{align*}
%
Platnost rovnosti $ \varphi(x \cdot y) = \varphi(x) \cdot \varphi(y) $ se ověří
analogicky. Zobrazení $ \varphi $ je tedy skutečně izomorfismus okruhů a zkoumané
prostory jsou proto izomorfní.
\end{proof}

Předpokládejme, že chceme provádět sérii výpočtů (sčítání, odčítání,
násobení) nad celými čísly a jsme dopředu schopni omezit výsledek nějakým číslem
$ m $. Pak tyto výpočty můžeme ekvivalentně provádět v okruhu $ \Zbb / m \Zbb $.
Avšak z důsledku \ref{Chin_Rem_Iso} plyne, že stejně tak můžeme výpočty provést
paralelně modulo prvočíselné faktory $ m $. V praxi $ m $ obvykle získáme tak,
že postupně přidáváme prvočísla dokud jejich součin není dostatečně velký.
Pak použijeme zobrazení $ \varphi $ z důkazu důsledku \ref{Chin_Rem_Iso},
čímž získáme výchozí reprezentanty v příslušných okruzích součinu okruhů.
Nyní můžeme paralelně aplikovat operace, které potřebujeme provést a konečně
pomocí konstrukce uvedené v důkazu věty \ref{Chin_Rem} spojíme částečné výsledky
a obdržíme výsledek původní úlohy.


\section{Výběr prvočísel}
Snadno se nahlédne, že výše uvedený Hadamardův odhad můžeme aplikovat i na prvky
matic ve Smithově normálním tvaru. Mějme libovolnou matici $ A $ jako na začátku
této kapitoly a označme $ \beta = (m^{1/2} \Vert A \Vert )^m $. Naším cílem bude
najít prvočísla $ p_1,\dots, p_k $ tak, aby $ \beta < p_1 \cdots p_k $. Zřejmě
bychom mohli postupně brát prvočísla $ 2, 3, 5, 7 \dots $, dokud by uvedená
podmínka nebyla splněna. Takto bychom však dostali prvočísel zbytečně mnoho. Na
druhou stranu chceme, aby tato prvočísla byla dostatečně malá tak, abychom
si pro rozumně velké matice vystačili se standardní 32-bitovou reprezentací
celého čísla. Co znamená rozumně velká matice bude zřejmé z následujících řádků.

Rozumný kompromis poskytuje \cite[Lemma 14]{triang}. Autor však tento výsledek
uvádí bez důkazu s odkazem na publikaci, ve které se nám nepodařilo takovéto
tvrzení vůbec najít, a to ani v nějaké obecnější podobě či jako pomocný výsledek
nějakého důkazu. Abychom předešli nejasnostem, dokážeme toto tvrzení v mírně
modifikované podobě pomocí následujícího tvrzení.


\begin{lem}[{\cite[Corollary 3.8]{primes}}] \label{num_primes_src}
Nechť $ \pi(a) = \left\vert \{ p \in \mathbb{P} \vert p \leq a \} \right\vert $. Pak
platí $ 3a / (5 \ln{a}) < \pi(2a) - \pi(a) $ pro všechna $ a \geq 20 \frac{1}{2} $.
\end{lem}

\begin{lem} \label{num_prim}
Buď $ x \geq 2 $ a $ l = 6 + \log_2 \log_2 x $.
Pak existuje nejméně $ \ceil{\frac{2^{l}}{5 (l - 1)}} $ prvočísel $ p $
takových, že $ 2^{l - 1} < p < 2^l $.
\end{lem}
\begin{proof}
Dosazením $ a = 2^{l - 1} $ do lemmatu \ref{num_primes_src} a postupnými úpravami
dostáváme
\begin{align*}
    \pi(2^{l}) - \pi(2^{l - 1}) > \frac{3 \cdot 2^{l - 1}}{5 \ln{2^{l - 1}}}
                                \geq \frac{2^{l}}{5 \log_2{2^{l - 1}}}
                                = \frac{2^{l}}{5 (l - 1)}.
\end{align*}
Použití lemmatu \ref{num_primes_src} je skutečně korektní, neboť
$ l \geq 6 $ z čehož plyne, že $ a \geq 32 $. Z definice funkce $ \pi(a) $ pak
získáme naše tvrzení.
\end{proof}
\begin{dus}
Buď $ \beta = (m^{1/2} \Vert A \Vert )^m $ Hadamardův odhad na determinant tak,
jako na začátku této sekce a nechť $ l = 6 + \log_2 \log_2 \beta $. Pak můžeme najít
$ s = \ceil{\frac{2^{l}}{5 (l - 1)}} $ prvočísel $ \{p_1, \dots, p_s\} $,
která je možno reprezentovat $ l $-bitovým celým číslem a navíc bude platit
$ \beta < p_1 \cdots p_s $.
\end{dus}
\begin{proof}
Uvažme prvočísla z lemmatu \ref{num_prim} a označme je $ \{p_1, \dots, p_s\} $.
Tato prvočísla můžeme zdola odhadnout $ 2^{l - 1} < p_i $,
z čehož plyne následující výpočet.
\begin{align*}
    p_1 \cdots p_s
        > (2^{l - 1}) ^ s
        \geq 2^{(l - 1) \frac{2^l}{5 (l - 1)}}
        = 2^{\frac{2^{6 + \log_2 \log_2 \beta}}{5}}
        = \beta^{\frac{2^6}{5}} > \beta
\end{align*}
Tím je důkaz hotov až na případ, kdy $ \beta \in \{0, 1\} $. Tyto možnosti ale
nejsou příliš zajímavé neboť v prvním případě je Smithův normální tvar nulová
matice a ve druhém pak skalár - jednička. V obou případech pak můžeme vzít
libovolné prvočíslo, které jistě bude větší než determinant.
\end{proof}

\begin{pozn}
Poznamenejme, že v praxi pro nějakou konkrétní úlohu můžeme mít k dispozici
podstatně lepší odhad na determinant nebo na prvky v hledaném Smithově normálním
tvaru. Uvedený postup pak bude fungovat úplně stejně, jen nahradíme $ \beta $
daným odhadem a dále postupujeme identicky.
\end{pozn}

Předpokládejme, že chceme vypočítat Smithův normální tvar matice o rozměrech
$ 10^4 \times 10^4 $. Pak nám budou pro výpočet stačit prvočísla jejiž bitová
délka bude $ l = 6 + \log_2(10^4 \log_2(10^2 \Vert A \Vert)) $. Pokud dosadíme
například $ \Vert A \Vert = 2^{31} $, zjistíme, že by nám stačila prvočísla
mající nejvýše $ 26 $ bitů, což je pro naše potřeby naprosto
postačující. Předpokládáme, že matice větších rozměrů již budou nad naše výpočetní
možnosti.

\section{Paralelizace algoritmů pro výpočet Smithova normálního tvaru}
Mějme opět matici $ A $ tak jako na začátku a uvažme prvočísla
$ \{ p_1, \dots, p_s \} $ z předchozí sekce. Článek \cite[Theorem 16]{triang}
uvádí, že operace algoritmu z věty \ref{RST_algo} můžeme provádět paralelně
v okruzích $ \Zbb / p_i \Zbb $. Avšak autor také podotýká, že aby byl algoritmus
korektní, musíme v algoritmu lemmatu \ref{RST_algo_lemma} postupovat poněkud
opatrněji. S pracovní matici $ B_k $, která označuje právě zpracováváný sloupec,
bychom měli vždy pracovat pouze ve standardní reprezentaci. To znamená, že při
inicializaci matice $ B_k $ musíme pomocí věty \ref{Chin_Rem} zobrazit příslušné
prvky matic v okruzích $ \Zbb / p_i \Zbb $ do okruhu $ \Zbb / m \Zbb $.

V praxi to pak znamená, že ve chvíli, kdy algoritmus potřebuje vypočítat nějaký
koeficient (například pomocí rošířeného Euklidova algoritmu), musíme prvky
potřebné pro výpočet daného koeficientu převést z modulárního systému do standardní
reprezentace pomocí Čínské zbytkové věty, vypočítat koeficient nad okruhem celých
čísel a pak pomocí tohoto koeficientu provést kýženou operaci nad maticemi v
okruzích $ \Zbb / p_i \Zbb $.

Autor článku \cite{triang} se
také zabývá tím, jak vypočítat rank profile potřebný pro výpočet redukovaného
schodovitého tvaru pomocí Čínské zbytkové věty. Ukazuje se \cite[Theorem 15]{triang},
že je skutečně možné efektivně rank profile vypočítat pomocí prvočísel $ p_i $
tak, že pracujeme v okruzích $ \Zbb / p_i \Zbb $.
Výpočet ekvivalentní trojúhelníkové matice z matice $ A $ tedy není problém.

Naneštěstí v článku \cite{SNF_Arne} se autor již problematikou počítání v
reziduálním systému nezabývá. To však můžeme na
pravit. Výpočet povedeme podobným
způsobem jako v případě výše uvedené paralelizace algoritmu pro výpočet RST.
Nejprve musíme identifikovat všechna místa algoritmu z věty \ref{SNF_Triang},
která vyžadují výpočet nějakých koeficientů. V lemmatu \ref{Sloup_elim_GCD}
se jedná o koeficient $ c $, který počítáme pomocí Bachova lemmatu. Lemma
\ref{Sloup_elim_SNF} pak používá rozšířený Euklidův algoritmus pro výpočet čísel
$ s, t $ a $ s_1 $. Analogický výpočet koeficientů $ s, t $ najdeme v lemmatu
\ref{extra_cols}. Na těchto třech místech proto musí dojít k synchornizaci výpočtu,
převodu příslušných prvků do standardní reprezentace, výpočtu potřebných
koeficientů a pak teprve může algoritmus pokračovat ve výpočtu v modulárních
systémech se získanými koeficienty.

Celkem tedy dostáváme algoritmus pro výpočet Smithova normálního tvaru, který
je schopen provádět většinu výpočtů ve standardní 32-bitové aritmetice. Navíc části
algoritmu, které nevyžadují výpočet zmíněných koeficientů, můžeme provádet
paralelně a využít tak plný potenciál dnešních vícejádrových procesorů.
V místě kde je potřeba udělat nějaké rozhodnutí (vypočítat koeficient),
je nutné pracovat s datovými typy pro reprezentaci libovolně velkého celého
čísla. V jednom okamžiku však takových čísel budeme potřebovat jen velmi málo
(obvykle se jedná pouze o vstupy do rozšířeného Euklidova algoritmu), a proto
tyto výpočty nebudou nijak významně zvyšovat paměťovou náročnost.